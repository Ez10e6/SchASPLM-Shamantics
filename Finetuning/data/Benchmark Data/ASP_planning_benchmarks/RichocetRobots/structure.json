{
  "instance_template": "dim_x(1..16). dim_y(1..16). robot(r1; r2; r3; r4). robot_at(r1, 1, 1, 0). target(r1, 5, 5). wall(1, 1, east). horizon(15).",
  "generator": "dir(north, 0, -1). dir(south, 0, 1). dir(east, 1, 0). dir(west, -1, 0). opp(north, south). opp(south, north). opp(east, west). opp(west, east). direction(D) :- dir(D, _, _). step(1..H) :- horizon(H). time(0..H) :- horizon(H). 1 { move(R, D, T) : robot(R), direction(D) } 1 :- step(T). full_wall(X, Y, D) :- wall(X, Y, D). full_wall(NX, NY, O) :- wall(X, Y, D), dir(D, DX, DY), opp(D, O), NX = X + DX, NY = Y + DY, dim_x(NX), dim_y(NY). full_wall(X, 1, north) :- dim_x(X). full_wall(X, Y, south) :- Y = #max { Y1 : dim_y(Y1) }, dim_x(X), dim_y(Y). full_wall(1, Y, west) :- dim_y(Y). full_wall(X, Y, east) :- X = #max { X1 : dim_x(X1) }, dim_x(X), dim_y(Y). obstacle(X, Y, D, T) :- full_wall(X, Y, D), time(T). obstacle(X, Y, D, T) :- dir(D, DX, DY), NX = X + DX, NY = Y + DY, robot_at(_, NX, NY, T - 1), time(T), dim_x(X), dim_y(Y). reached(R, X, Y, T) :- move(R, D, T), robot_at(R, X, Y, T - 1). reached(R, NX, NY, T) :- reached(R, X, Y, T), move(R, D, T), dir(D, DX, DY), NX = X + DX, NY = Y + DY, dim_x(NX), dim_y(NY), not full_wall(X, Y, D), not robot_at(_, NX, NY, T - 1). robot_at(R, X, Y, T) :- reached(R, X, Y, T), move(R, D, T), dir(D, DX, DY), obstacle(X, Y, D, T). robot_at(R, X, Y, T) :- robot_at(R, X, Y, T - 1), not moving(R, T), step(T). moving(R, T) :- move(R, _, T).",
  "hard_constraints": [
    {
      "description": "Only one robot can be shoved in a direction at any given time step.",
      "asp_rule": ":- step(T), C = #count { R, D : move(R, D, T) }, C > 1."
    },
    {
      "description": "Sanity check: did we actually move? If you slide and end up where you started, that's a wasted move.",
      "asp_rule": ":- move(R, D, T), robot_at(R, X, Y, T - 1), robot_at(R, X, Y, T)."
    },
    {
      "description": "The goal is the whole point. The target robot better be at the target coordinates by the end of the line.",
      "asp_rule": ":- target(R, TX, TY), horizon(H), not robot_at(R, TX, TY, H)."
    }
  ],
  "soft_constraints": [
    {
      "description": "We want the quickest path possible, so every move costs us points.",
      "asp_rule": "penalty(\"step_cost\", T, 1) :- move(R, D, T)."
    }
  ],
  "global_objective": "#minimize { C,T,N : penalty(N, T, C) }."
}