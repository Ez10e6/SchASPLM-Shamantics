{
  "instance_template": "player(p1). stone(s1). stone(s2). loc(1..10). adj(1, 2, n). is_goal(5). is_wall(6). step(1..20). at(p1, 1, 0). at(s1, 2, 0).",
  "generator": "{ move(L1, L2, T) : adj(L1, L2, D); push(L1, L2, L3, T) : adj(L1, L2, D), adj(L2, L3, D) } <= 1 :- step(T).\nat(P, L2, T) :- move(L1, L2, T), player(P).\nat(P, L2, T) :- push(L1, L2, L3, T), player(P).\nat(S, L3, T) :- push(L1, L2, L3, T), at(S, L2, T-1), stone(S).\nat(E, L, T) :- at(E, L, T-1), not moved(E, T), step(T).\nmoved(P, T) :- move(L1, L2, T), player(P).\nmoved(P, T) :- push(L1, L2, L3, T), player(P).\nmoved(S, T) :- push(L1, L2, L3, T), at(S, L2, T-1), stone(S).",
  "hard_constraints": [
    {
      "description": "A player can only initiate a move if they are currently standing at the starting location of that move.",
      "asp_rule": ":- move(L1, L2, T), not at(P, L1, T-1), player(P)."
    },
    {
      "description": "Movement is restricted to clear spaces; a player cannot move into a square that is currently occupied by a stone.",
      "asp_rule": ":- move(L1, L2, T), at(S, L2, T-1), stone(S)."
    },
    {
      "description": "The grid contains static obstacles; neither the player nor a stone can ever enter a square designated as a wall.",
      "asp_rule": ":- move(L1, L2, T), is_wall(L2)."
    },
    {
      "description": "A push action requires the player to be positioned directly adjacent to a stone and for that stone to be at the expected location.",
      "asp_rule": ":- push(L1, L2, L3, T), not at(P, L1, T-1), player(P)."
    },
    {
      "description": "You cannot push a stone into another stone; the square behind the stone being pushed must be completely clear.",
      "asp_rule": ":- push(L1, L2, L3, T), at(S2, L3, T-1), stone(S2)."
    },
    {
      "description": "The destination square of a push must not be a wall.",
      "asp_rule": ":- push(L1, L2, L3, T), is_wall(L3)."
    },
    {
      "description": "The puzzle is solved only if every designated goal location contains a stone at the final time step.",
      "asp_rule": ":- is_goal(L), M = #max { Ts : step(Ts) }, not stone_at(L, M).\nstone_at(L, T) :- at(S, L, T), stone(S)."
    }
  ],
  "soft_constraints": [
    {
      "description": "To find the most efficient solution, we prefer sequences with the fewest number of actions.",
      "asp_rule": "penalty(\"action\", T, 1) :- move(L1, L2, T).\npenalty(\"action\", T, 1) :- push(L1, L2, L3, T)."
    }
  ],
  "global_objective": "#minimize { C,T,N : penalty(N, T, C) }."
}