{
  "instance_template": "field(X, Y). \ngoal_on(X, Y). \ninit_on(X, Y). \nconnect(X, Y, Direction). \nmax_steps(N). \ndir(D). \ninverse(D1, D2).",
  "generator": "step(S) :- max_steps(S), 0 < S.\nstep(T) :- step(S), T = S-1, 1 < S.\n\n{ occurs(some_action, T) } :- step(T).\n\n{ rrpush(T); ccpush(T) } = 1 :- neg_goal(S), S = T-1, occurs(some_action, T).\n\n{ rpush(X, T) : row(X) } = 1 :- rrpush(T).\n{ cpush(Y, T) : col(Y) } = 1 :- ccpush(T).\n\n{ push(X, e, T); push(X, w, T) } = 1 :- rpush(X, T).\n{ push(Y, n, T); push(Y, s, T) } = 1 :- cpush(Y, T).",
  "hard_constraints": [
    {
      "description": "Now class, we must track how fields move! If a row or column is pushed, we calculate the new position of every field. If it isn't pushed, it simply stays where it is in the next time step.",
      "asp_rule": "shift(XX,YY,X,Y,T) :- neighbor(e,XX,YY,X,Y), push(XX,e,T).\nshift(XX,YY,X,Y,T) :- neighbor(w,XX,YY,X,Y), push(XX,w,T).\nshift(XX,YY,X,Y,T) :- neighbor(n,XX,YY,X,Y), push(YY,n,T).\nshift(XX,YY,X,Y,T) :- neighbor(s,XX,YY,X,Y), push(YY,s,T).\nshift( X, Y,X,Y,T) :- step(T), field(X,Y), not push(X,e,T), not push(X,w,T), not push(Y,n,T), not push(Y,s,T)."
    },
    {
      "description": "Pay close attention: the physical properties of our tiles\u2014the connections and the goal marker\u2014must move whenever the field they are on is shifted to a new coordinate!",
      "asp_rule": "conn(X,Y,D,T) :- conn(XX,YY,D,S), S = T-1, dir(D), shift(XX,YY,X,Y,T).\ngoal(X,Y,T) :- goal(XX,YY,S), S = T-1, shift(XX,YY,X,Y,T)."
    },
    {
      "description": "Imagine water flowing through a pipe! Reachability spreads from a tile to its neighbor if, and only if, both tiles have matching connections that face each other.",
      "asp_rule": "reach(X,Y,T) :- reach(XX,YY,S), S = T-1, shift(XX,YY,X,Y,T).\nreach(X,Y,T) :- reach(XX,YY,T), dneighbor(D,XX,YY,X,Y), conn(XX,YY,D,T), conn(X,Y,E,T), inverse(D,E)."
    },
    {
      "description": "Remember our ultimate objective! We must define a failure state where the goal field is not reached. We then use a constraint to forbid any scenario where the goal remains unreached at the final time step.",
      "asp_rule": "neg_goal(T) :- goal(X,Y,T), not reach(X,Y,T).\n:- neg_goal(T), step(T), not step(T+1)."
    },
    {
      "description": "To correctly model the movement, we must define how neighbors work on our grid, including the 'wrap-around' logic where pushing something off the right edge makes it appear on the left!",
      "asp_rule": "neighbor(D,X,Y,XX,YY) :- dneighbor(D,X,Y,XX,YY).\nneighbor(n,X,Y, 1, Y) :- field(X,Y), num_rows(X).\nneighbor(s,1,Y, X, Y) :- field(X,Y), num_rows(X).\nneighbor(e,X,Y, X, 1) :- field(X,Y), num_cols(Y).\nneighbor(w,X,1, X, Y) :- field(X,Y), num_cols(Y)."
    }
  ],
  "soft_constraints": []
}