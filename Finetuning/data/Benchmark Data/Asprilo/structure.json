{
  "instance_template": "robot(1). shelf(1). station(1). product(1). order(1). ordered(order(1), product(1)). shelf_inventory(shelf(1), product(1)). position(node(1,1)). time(1..10). horizon(10).",
  "generator": "direction((0,1);(0,-1);(1,0);(-1,0)). nextto((X,Y),(DX,DY),(X+DX,Y+DY)) :- direction((DX,DY)), position(node(X,Y)), position(node(X+DX,Y+DY)). { move(R,D,T) : direction(D) ; pickup(R,S,T) : shelf(S) ; putdown(R,S,T) : shelf(S) ; deliver(R,S,O,A,T) : shelf_inventory(S,A), ordered(O,A) } 1 :- robot(R), time(T). position(R,C,T) :- move(R,D,T), position(R,C',T-1), nextto(C',D,C). position(R,C,T) :- position(R,C,T-1), not move(R,_,T), robot(R), time(T). carries(R,S,T) :- pickup(R,S,T). carries(R,S,T) :- carries(R,S,T-1), not putdown(R,S,T), time(T). position(S,C,T) :- carries(R,S,T), position(R,C,T). position(S,C,T) :- position(S,C,T-1), N = #count { R : carries(R,S,T) }, N = 0, shelf(S), time(T). processed(A,O,T) :- deliver(R,S,O,A,T). processed(A,O,T) :- processed(A,O,T-1), time(T).",
  "hard_constraints": [
    {
      "description": "The cardinality of robots occupying a single grid vertex at any discrete temporal index must not exceed one.",
      "asp_rule": ":- position(node(X,Y)), time(T), N = #count { R : position(R,node(X,Y),T) }, N > 1."
    },
    {
      "description": "The cardinality of shelves occupying a single grid vertex at any discrete temporal index must not exceed one.",
      "asp_rule": ":- position(node(X,Y)), time(T), N = #count { S : position(S,node(X,Y),T) }, N > 1."
    },
    {
      "description": "The movement of a robot is restricted to adjacent grid vertices defined by cardinal directions.",
      "asp_rule": ":- move(R,D,T), position(R,C,T-1), not nextto(C,D,_)."
    },
    {
      "description": "A robot may only perform a pickup action if its current grid location is identical to that of the target shelf.",
      "asp_rule": ":- pickup(R,S,T), position(R,C,T-1), position(S,C',T-1), C != C'."
    },
    {
      "description": "A robot is prohibited from initiating a pickup action if it is already in possession of a shelf.",
      "asp_rule": ":- pickup(R,S,T), carries(R,_,T-1)."
    },
    {
      "description": "A shelf may not be picked up if it is currently being transported by another robot.",
      "asp_rule": ":- pickup(R,S,T), carries(_,S,T-1)."
    },
    {
      "description": "A robot may only perform a putdown action if it is currently transporting the specified shelf.",
      "asp_rule": ":- putdown(R,S,T), not carries(R,S,T-1)."
    },
    {
      "description": "The simultaneous exchange of spatial coordinates between two distinct robots within a single temporal transition is forbidden.",
      "asp_rule": ":- position(R1,C1,T-1), position(R1,C2,T), position(R2,C2,T-1), position(R2,C1,T), R1 < R2."
    },
    {
      "description": "Product delivery is strictly permitted only when the robot transporting the requisite shelf is situated at a designated picking station.",
      "asp_rule": ":- deliver(R,S,O,A,T), position(R,C,T), not station(C)."
    },
    {
      "description": "A delivery action requires the robot to be actively carrying the shelf containing the ordered product.",
      "asp_rule": ":- deliver(R,S,O,A,T), not carries(R,S,T)."
    },
    {
      "description": "Every product specified in a customer order must reach a processed state by the terminal time index of the horizon.",
      "asp_rule": ":- ordered(O,A), horizon(H), not processed(A,O,H)."
    },
    {
      "description": "All shelves must be released from robot possession and placed on the grid by the terminal temporal index.",
      "asp_rule": ":- carries(_,_,H), horizon(H)."
    }
  ],
  "soft_constraints": [
    {
      "description": "A penalty is incurred for every active movement, pickup, or putdown action to minimize the total energy expenditure.",
      "asp_rule": "penalty(\"action_cost\", (R,T), 1) :- move(R,D,T). penalty(\"action_cost\", (R,T), 1) :- pickup(R,S,T). penalty(\"action_cost\", (R,T), 1) :- putdown(R,S,T)."
    }
  ],
  "global_objective": "#minimize { C,Name,Args : penalty(Name,Args,C) }."
}