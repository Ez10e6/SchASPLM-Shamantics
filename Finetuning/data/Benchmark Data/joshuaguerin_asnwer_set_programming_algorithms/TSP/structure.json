{
  "instance_template": "node(1..3). start(1). end(3). edge(1,2,10). edge(2,3,20).",
  "generator": "edge(U,V,C) :- edge(V,U,C). { path(U,V,C) : edge(U,V,C) }.",
  "hard_constraints": [
    {
      "description": "Start node no incoming edges.",
      "asp_rule": ":- start(V), path(U,V,C)."
    },
    {
      "description": "End node no outgoing edges.",
      "asp_rule": ":- end(U), path(U,V,C)."
    },
    {
      "description": "Non-end nodes exactly one outgoing edge.",
      "asp_rule": ":- node(U), not end(U), N = #count { V,C : path(U,V,C) }, N != 1."
    },
    {
      "description": "Non-start nodes exactly one incoming edge.",
      "asp_rule": ":- node(V), not start(V), N = #count { U,C : path(U,V,C) }, N != 1."
    },
    {
      "description": "Start node is reachable.",
      "asp_rule": "reachable(V) :- start(V)."
    },
    {
      "description": "Transitive path reachability.",
      "asp_rule": "reachable(V) :- reachable(U), path(U,V,C)."
    },
    {
      "description": "All nodes reachable from start.",
      "asp_rule": ":- node(V), not reachable(V)."
    }
  ],
  "soft_constraints": [
    {
      "description": "Minimize cost of selected edges.",
      "asp_rule": "penalty(\"edge_cost\", (U,V), C) :- path(U,V,C)."
    }
  ],
  "global_objective": "#minimize { C,U,V : penalty(\"edge_cost\", (U,V), C) }."
}