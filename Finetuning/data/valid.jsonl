{"messages": [{"role": "system", "content": "You are an expert AI researcher. Translate the following natural language problem description into syntactically correct clingo ASP code."}, {"role": "user", "content": "You\u2019ve been tasked with laying out a rich three\u2011day symposium featuring twelve\nworkshops in four disciplines \u2014 Artificial Intelligence, Physics, Mathematics,\nand Linguistics \u2014 across a venue with four rooms. Each day unfolds in three\nsessions \u2014 morning, midday, and evening \u2014 and every workshop must claim at least \none room\u2013time slot without any double\u2011booking.\nTo keep things balanced, no room may see more than two workshops per day, and\nthey can\u2019t be back\u2011to\u2011back; a break must separate any two uses of the same room.\nAlso, Room\u202f2 goes dark at evening, while Room\u202f4\u2019s limited capacity rules out\nany AI or Physics sessions there.\nYour thematic requirements narrow the field further: AI workshops belong\nexclusively in morning sessions, and Physics must stay on Day\u202f1 or Day\u202f2, never\nspilling into the final day. All Mathematics workshops must settle into either\nRoom\u202f1 or Room\u202f3, whereas Linguistics sessions need their own moments\u2014no two\nmay ever run concurrently.\nAnother wrinkle: each room should host only one discipline per day, so you can\u2019t\nmix topics under the same roof in a single day. To guarantee breadth, you\u2019ll\ninclude at least one workshop from each of the four fields every day. For a \nneat bookend, the very first workshop must be an AI presentation, \nand the closing workshop must be a Linguistics talk.\nBeyond satisfying these rules, you should aim to fill as many rooms as possible \nin every timeslot while keeping unused slots to a minimum\u2014yet stop short of \nsqueezing in extra sessions that would break any of the constraints. In other\nwords, maximize room utilization without ever overstepping the scheduling logic\nyou\u2019ve been given."}, {"role": "assistant", "content": "% Workshops and Topics\nworkshop(1..12).\ntopic(\"AI\"; \"Physics\"; \"Math\"; \"Linguistics\").\n1 { topicOf(W, T) : topic(T) } 1 :- workshop(W).\n\n% Time and Structure\nday(1..3).\nslot(\"morning\"; \"midday\"; \"evening\").\nroom(1..4).\n\n% Every workshop must be scheduled\n1 {scheduled(W, R, S, D) : room(R), slot(S), day(D)} :- workshop(W).\n\n% Only one workshop per room per time\n:- scheduled(W1, R, S, D), scheduled(W2, R, S, D), W1 != W2.\n\n% At most 2 sessions per room per day\n{scheduled(W, R, S, D) : workshop(W), slot(S)} 2 :- room(R), day(D).\n\n% No room can be used in adjacent time slots\nadjacent(\"morning\", \"midday\").\nadjacent(\"midday\", \"evening\").\n:- scheduled(_, R, S1, D), scheduled(_, R, S2, D), adjacent(S1, S2).\n\n% Room 2 cannot be used in the evening\n:- scheduled(_, 2, \"evening\", _).\n\n% Room 4 cannot host AI or Physics\n:- scheduled(W, 4, _, _), topicOf(W, \"AI\").\n:- scheduled(W, 4, _, _), topicOf(W, \"Physics\").\n\n% AI workshops must be in the morning\n:- scheduled(W, _, S, _), topicOf(W, \"AI\"), S != \"morning\".\n\n% Physics workshops must be held on the first or second day\n:- scheduled(W, _, _, D), topicOf(W, \"Physics\"), D = 3.\n\n% All Math workshops must be scheduled in Room 1 or Room 3\n:- scheduled(W, R, _, _), topicOf(W, \"Math\"), R != 1, R != 3.\n\n% Linguistics workshops must not overlap in time\n:- scheduled(W1, _, S, D), scheduled(W2, _, S, D), topicOf(W1, \"Linguistics\"),\ntopicOf(W2, \"Linguistics\"), W1 != W2.\n\n% No room may host workshops from different topics on the same day\n:- scheduled(W1, R, _, D), scheduled(W2, R, _, D), topicOf(W1, T1),\ntopicOf(W2, T2), T1 != T2.\n\n% At least one workshop per topic must occur each day\n:- day(D), topic(T), not scheduled(_, _, _, D) : topicOf(_, T).\n\n% Time encoding for total ordering\nslotOrder(\"morning\", 1).\nslotOrder(\"midday\", 2).\nslotOrder(\"evening\", 3).\n\n% Compute time index\ntimeIndex(D, S, I) :- day(D), slot(S), slotOrder(S, O), I = (D - 1) * 3 + O.\n\n% Assign each scheduled workshop its time index\nwTime(W, I) :- scheduled(W, _, S, D), timeIndex(D, S, I).\n\n% Find the minimum and maximum index among all scheduled workshops\nminTime(I) :- I = #min {J : wTime(_, J)}.\nmaxTime(I) :- I = #max {J : wTime(_, J)}.\n\n% First workshop must be AI\n:- wTime(W, I), minTime(I), not topicOf(W, \"AI\").\n\n% Last workshop must be Linguistics\n:- wTime(W, I), maxTime(I), not topicOf(W, \"Linguistics\").\n\n% Maximize the number of rooms used in each time slot\nused(R, S, D) :- scheduled(_, R, S, D).\nroomsUsed(N, S, D) :- N = #count{R : used(R, S, D)}, slot(S), day(D).\n#maximize {N : roomsUsed(N, S, D)}.\n\n% Minimize idle slots\nidle(R, S, D) :- room(R), slot(S), day(D), not used(R, S, D).\nnum_idle(N) :- N = #count{R, S, D: idle(R, S, D) }.\n#minimize { N: num_idle(N) }.\n"}]}
{"messages": [{"role": "system", "content": "You are an expert AI researcher. Translate the following structured intermediate representation (IR) into syntactically correct clingo ASP code."}, {"role": "user", "content": "Robot starts at A.\nLocations: A, B, C, D, E.\nAdjacent nodes: (A\u2013B), (A\u2013C), (B\u2013D), (C\u2013E).\nThe robot can only move between adjacent nodes.\nThere are 6 timesteps.\nDelivery destinations: D, E.\nEach delivery location must be visited exactly once."}, {"role": "assistant", "content": "% Locations: A, B, C, D, E\nloc(\"A\"; \"B\"; \"C\"; \"D\"; \"E\").\n\n% Adjacent nodes: (A\u2013B), (A\u2013C), (B\u2013D), (C\u2013E)\nedge(\"A\", \"B\").\nedge(\"A\", \"C\").\nedge(\"B\", \"D\").\nedge(\"C\", \"E\").\n\n% The robot can only move between adjacent nodes\n1 { at(L, T) : loc(L) } 1 :- time(T).\n:- at(L1, T), at(L2, T+1), not edge(L1, L2), not edge(L2, L1), time(T).\n\n% There are 6 timesteps\ntime(0..6).\n\n% Robot starts at A\nat(\"A\", 0).\n\n% Delivery destinations: D, E\ndeliver_to(\"D\"; \"E\").\n\n% Each delivery location must be visited exactly once\n1{ at(L, T) : time(T) }1 :- deliver_to(L)."}]}
{"messages": [{"role": "system", "content": "You are an expert AI researcher. Translate the following natural language problem description into syntactically correct clingo ASP code."}, {"role": "user", "content": "You are assembling a basic custom PC build using three components: a CPU, a GPU, and a motherboard.\nThere are two options for each component type:\nCPUs: Ryzen5 or i5\nGPUs: GTX1660 or RX580\nMotherboards: B450 or Z390\nEach final build must include exactly one CPU, one GPU, and one motherboard.\nHowever, there are compatibility rules:\nThe Ryzen5 CPU is only compatible with the B450 motherboard.\nThe i5 CPU is only compatible with the Z390 motherboard.\nThe RX580 GPU is not compatible with the Z390 motherboard.\nYou must select a valid combination of components that satisfies all compatibility constraints."}, {"role": "assistant", "content": "% Select exactly one CPU from {Ryzen5, i5}.\ncpu(\"Ryzen5\"; \"i5\").\n1 { selected_cpu(C) : cpu(C) } 1.\n\n% Select exactly one GPU from {GTX1660, RX580}.\ngpu(\"GTX1660\"; \"RX580\").\n1 { selected_gpu(G) : gpu(G) } 1.\n\n% Select exactly one motherboard from {B450, Z390}.\nmobo(\"B450\"; \"Z390\").\n1 { selected_mobo(M) : mobo(M) } 1.\n\n% The Ryzen5 CPU requires the B450 motherboard.\n:- selected_cpu(\"Ryzen5\"), selected_mobo(M), M != \"B450\".\n\n% The i5 CPU requires the Z390 motherboard.\n:- selected_cpu(\"i5\"), selected_mobo(M), M != \"Z390\".\n\n% The RX580 GPU is incompatible with the Z390 motherboard.\n:- selected_gpu(\"RX580\"), selected_mobo(\"Z390\").\n"}]}
{"messages": [{"role": "system", "content": "You are an expert AI researcher. Translate the following natural language problem description into syntactically correct clingo ASP code."}, {"role": "user", "content": "You are building a basic smartphone plan for a user. \nThe plan must include one data plan, one phone model, and one accessory.\nThe choices are:\nData Plans: BasicData, PremiumData\nPhone Models: ModelX, ModelY\nAccessories: CaseA, CaseB\nThe following compatibility constraints must be respected:\nBasicData is not compatible with ModelY.\nModelX requires CaseA.\nPremiumData cannot be used with CaseA.\nChoose a valid combination of components satisfying all constraints."}, {"role": "assistant", "content": "% Select exactly one data plan from {BasicData, PremiumData}.\nplan(\"BasicData\"; \"PremiumData\").\n1 { selected_plan(P) : plan(P) } 1.\n\n% Select exactly one phone model from {ModelX, ModelY}.\nphone(\"ModelX\"; \"ModelY\").\n1 { selected_phone(M) : phone(M) } 1.\n\n% Select exactly one accessory from {CaseA, CaseB}.\naccessory(\"CaseA\"; \"CaseB\").\n1 { selected_accessory(A) : accessory(A) } 1.\n\n% BasicData is not compatible with ModelY.\n:- selected_plan(\"BasicData\"), selected_phone(\"ModelY\").\n\n% ModelX requires CaseA.\n:- selected_phone(\"ModelX\"), selected_accessory(A), A != \"CaseA\".\n\n% PremiumData cannot be used with CaseA.\n:- selected_plan(\"PremiumData\"), selected_accessory(\"CaseA\").\n"}]}
{"messages": [{"role": "system", "content": "You are an expert AI researcher. Translate the following natural language problem description into syntactically correct clingo ASP code."}, {"role": "user", "content": "Procurement has turned philosophical: \u201cDon\u2019t always buy the most powerful; buy the right\npowerful.\u201d You\u2019re assembling a balanced data-processing workstation, and the specs you must\nnavigate are less about raw numbers and more about proportionality.\nCPUs \u2014 FalconX ($600, 125 pts), CoreZen ($500, 115 pts), EcoMini ($300, 90 pts)\nGPUs \u2014 TitanZ ($700, 135 pts), MidlineGT ($500, 100 pts), Pixie ($400, 95 pts)\nDrives \u2014 FlashNova ($250, 110 pts), Terabox ($300, 100 pts), BudgetDisk ($150, 60 pts)\nEach component must be selected from its category. But the trick is in how these relate.\nThe component with the middle performance value (not highest or lowest) must be the cheapest\namong the three selected parts.\nIf you pick a CPU worth more than $500, you can\u2019t pair it with the Pixie GPU.\nAvoid configurations where the performance spread (max - min) exceeds 50 points.\nIf you select the FlashNova SSD, the GPU must score at least 100.\nYou must select exactly two components whose price is above $300 and the GPU\u2019s performance\nmust fall between the CPU and drive\u2014i.e., not the highest or lowest."}, {"role": "assistant", "content": "% CPUs = {FalconX, CoreZen, EcoMini}.\ncpu(\"FalconX\"; \"CoreZen\"; \"EcoMini\").\n\n% Costs: [FalconX: 600, CoreZen: 500, EcoMini: 300].\ncost(\"FalconX\", 600; \"CoreZen\", 500; \"EcoMini\", 300).\n\n% Performance: [FalconX: 125, CoreZen: 115, EcoMini: 90].\nperf(\"FalconX\", 125; \"CoreZen\", 115; \"EcoMini\", 90).\n\n% GPUs = {TitanZ, MidlineGT, Pixie}.\ngpu(\"TitanZ\"; \"MidlineGT\"; \"Pixie\").\n\n% Costs: [TitanZ: 700, MidlineGT: 500, Pixie: 400].\ncost(\"TitanZ\", 700; \"MidlineGT\", 500; \"Pixie\", 400).\n\n% Performance: [TitanZ: 135, MidlineGT: 100, Pixie: 95].\nperf(\"TitanZ\", 135; \"MidlineGT\", 100; \"Pixie\", 95).\n\n% Drives = {FlashNova, Terabox, BudgetDisk}.\ndrive(\"FlashNova\"; \"Terabox\"; \"BudgetDisk\").\n\n% Costs: [FlashNova: 250, Terabox: 300, BudgetDisk: 150].\ncost(\"FlashNova\", 250; \"Terabox\", 300; \"BudgetDisk\", 150).\n\n% Performance: [FlashNova: 110, Terabox: 100, BudgetDisk: 60].\nperf(\"FlashNova\", 110; \"Terabox\", 100; \"BudgetDisk\", 60).\n\n% Select one CPU, one GPU, and one drive.\n1 { selected_cpu(C) : cpu(C) } 1.\n1 { selected_gpu(G) : gpu(G) } 1.\n1 { selected_drive(D) : drive(D) } 1.\n\n% Mid-performance component must be the cheapest.\nselected(X) :- selected_cpu(X).\nselected(X) :- selected_gpu(X).\nselected(X) :- selected_drive(X).\n\nmax_perf(P) :- P = #max {V : perf(X, V), selected(X)}.\nmin_perf(P) :- P = #min {V : perf(X, V), selected(X)}.\nmid_component(X) :- selected(X), perf(X, P), not min_perf(P), not max_perf(P).\n\ncheapest(X) :- cost(X, C), selected(X), C = #min {C1 : cost(X1, C1), selected(X1)}.\n:- mid_component(X1), cheapest(X2), X1 != X2.\n\n% If CPU > $500 can not use Pixie GPU.\n:- selected_cpu(C), cost(C, VC), VC > 500, selected_gpu(\"Pixie\").\n\n% Max - min performance \u2264 50.\n:- max_perf(H), min_perf(L),  H > L + 50.\n\n% If drive is FlashNova, GPU performance \u2265 100.\n:- selected_drive(\"FlashNova\"), selected_gpu(G), perf(G, P), P < 100.\n\n% Exactly two selected components must cost > $300.\n:- N != 2, N = #count {X : selected(X), cost(X, V), V > 300}.\n\n% GPU performance must be between CPU and drive.\n:- mid_component(X), not gpu(X)."}]}
{"messages": [{"role": "system", "content": "You are an expert AI researcher. Translate the following structured intermediate representation (IR) into syntactically correct clingo ASP code."}, {"role": "user", "content": "CPUs = {FalconX, CoreZen, EcoMini};\nCosts: [600, 500, 300]; Performance: [125, 115, 90].\nGPUs = {TitanZ, MidlineGT, Pixie};\nCosts: [700, 500, 400]; Performance: [135, 100, 95].\nDrives = {FlashNova, Terabox, BudgetDisk};\nCosts: [250, 300, 150]; Performance: [110, 100, 60].\nSelect one CPU, one GPU, one drive.\nMid-performance component must be the cheapest.\nIf CPU > $500 can not use Pixie GPU.\nMax - min performance \u2264 50.\nIf drive is FlashNova, GPU performance \u2265 100.\nExactly two selected components must cost > $300.\nGPU performance must be between CPU and drive."}, {"role": "assistant", "content": "% CPUs = {FalconX, CoreZen, EcoMini}.\ncpu(\"FalconX\"; \"CoreZen\"; \"EcoMini\").\n\n% Costs: [FalconX: 600, CoreZen: 500, EcoMini: 300].\ncost(\"FalconX\", 600; \"CoreZen\", 500; \"EcoMini\", 300).\n\n% Performance: [FalconX: 125, CoreZen: 115, EcoMini: 90].\nperf(\"FalconX\", 125; \"CoreZen\", 115; \"EcoMini\", 90).\n\n% GPUs = {TitanZ, MidlineGT, Pixie}.\ngpu(\"TitanZ\"; \"MidlineGT\"; \"Pixie\").\n\n% Costs: [TitanZ: 700, MidlineGT: 500, Pixie: 400].\ncost(\"TitanZ\", 700; \"MidlineGT\", 500; \"Pixie\", 400).\n\n% Performance: [TitanZ: 135, MidlineGT: 100, Pixie: 95].\nperf(\"TitanZ\", 135; \"MidlineGT\", 100; \"Pixie\", 95).\n\n% Drives = {FlashNova, Terabox, BudgetDisk}.\ndrive(\"FlashNova\"; \"Terabox\"; \"BudgetDisk\").\n\n% Costs: [FlashNova: 250, Terabox: 300, BudgetDisk: 150].\ncost(\"FlashNova\", 250; \"Terabox\", 300; \"BudgetDisk\", 150).\n\n% Performance: [FlashNova: 110, Terabox: 100, BudgetDisk: 60].\nperf(\"FlashNova\", 110; \"Terabox\", 100; \"BudgetDisk\", 60).\n\n% Select one CPU, one GPU, and one drive.\n1 { selected_cpu(C) : cpu(C) } 1.\n1 { selected_gpu(G) : gpu(G) } 1.\n1 { selected_drive(D) : drive(D) } 1.\n\n% Mid-performance component must be the cheapest.\nselected(X) :- selected_cpu(X).\nselected(X) :- selected_gpu(X).\nselected(X) :- selected_drive(X).\n\nmax_perf(P) :- P = #max {V : perf(X, V), selected(X)}.\nmin_perf(P) :- P = #min {V : perf(X, V), selected(X)}.\nmid_component(X) :- selected(X), perf(X, P), not min_perf(P), not max_perf(P).\n\ncheapest(X) :- cost(X, C), selected(X), C = #min {C1 : cost(X1, C1), selected(X1)}.\n:- mid_component(X1), cheapest(X2), X1 != X2.\n\n% If CPU > $500 can not use Pixie GPU.\n:- selected_cpu(C), cost(C, VC), VC > 500, selected_gpu(\"Pixie\").\n\n% Max - min performance \u2264 50.\n:- max_perf(H), min_perf(L),  H > L + 50.\n\n% If drive is FlashNova, GPU performance \u2265 100.\n:- selected_drive(\"FlashNova\"), selected_gpu(G), perf(G, P), P < 100.\n\n% Exactly two selected components must cost > $300.\n:- N != 2, N = #count {X : selected(X), cost(X, V), V > 300}.\n\n% GPU performance must be between CPU and drive.\n:- mid_component(X), not gpu(X)."}]}
{"messages": [{"role": "system", "content": "You are an expert AI researcher. Translate the following structured intermediate representation (IR) into syntactically correct clingo ASP code."}, {"role": "user", "content": "CPUs = {BoltX, HydraPro, LiteCore}.\nWattages: [BoltX: 85, HydraPro: 125, LiteCore: 60].\nCosts: [BoltX: 400, HydraPro: 550, LiteCore: 350].\nGPUs = {StormZ, Nebula9, VegaLite}.\nWattages: [StormZ: 180, Nebula9: 150, VegaLite: 95].\nCosts: [StormZ: 800, Nebula9: 650, VegaLite: 500].\nPSUs = {PowerMax750, Eco600, Titan900}.\nCapacities: [PowerMax750: 750, Eco600: 600, Titan900: 900].\nCosts: [PowerMax750: 200, Eco600: 150, Titan900: 250].\nSelect one CPU, one GPU, one PSU.\nTotal CPU+GPU draw \u2264 PSU capacity - 100.\nMost power-hungry selected component must also be the most expensive.\nIncompatible pairs: (HydraPro, VegaLite), (Eco600, StormZ).\nDo not select all three cheapest components.\nNo two selected components can differ in cost by more than $400."}, {"role": "assistant", "content": "% CPUs = {BoltX, HydraPro, LiteCore};\ncpu(\"BoltX\"; \"HydraPro\"; \"LiteCore\").\n\n% Wattages: [BoltX: 85, HydraPro: 125, LiteCore: 60].\nwatt(\"BoltX\", 85; \"HydraPro\", 125; \"LiteCore\", 60).\n\n% Costs: [BoltX: 400, HydraPro: 550, LiteCore: 350].\ncost(\"BoltX\", 400; \"HydraPro\", 550; \"LiteCore\", 350).\n\n% GPUs = {StormZ, Nebula9, VegaLite};\ngpu(\"StormZ\"; \"Nebula9\"; \"VegaLite\").\n\n% Wattages: [StormZ: 180, Nebula9: 150, VegaLite: 95].\nwatt(\"StormZ\", 180; \"Nebula9\", 150; \"VegaLite\", 95).\n\n% Costs: [StormZ: 800, Nebula9: 650, VegaLite: 500].\ncost(\"StormZ\", 800; \"Nebula9\", 650; \"VegaLite\", 500).\n\n% PSUs = {PowerMax750, Eco600, Titan900};\npsu(\"PowerMax750\"; \"Eco600\"; \"Titan900\").\n\n% Capacities: [PowerMax750: 750, Eco600: 600, Titan900: 900].\ncapacity(\"PowerMax750\", 750; \"Eco600\", 600; \"Titan900\", 900).\n\n% Costs: [PowerMax750: 200, Eco600: 150, Titan900: 250].\ncost(\"PowerMax750\", 200; \"Eco600\", 150; \"Titan900\", 250).\n\n% Select one CPU, one GPU, one PSU.\n1 { selected_cpu(C) : cpu(C) } 1.\n1 { selected_gpu(G) : gpu(G) } 1.\n1 { selected_psu(P) : psu(P) } 1.\n\n% Total CPU+GPU draw \u2264 PSU capacity - 100.\nselected_total_draw(D) :- selected_cpu(C), selected_gpu(G), watt(C, WC), watt(G, WG), D = WC + WG.\n:- selected_psu(P), selected_total_draw(D), capacity(P, CP), D > CP - 100.\n\n% Most power-hungry part must also be most expensive\nselected(X) :- selected_cpu(X).\nselected(X) :- selected_gpu(X).\nselected(X) :- selected_psu(X).\n\nmax_watt(X) :- watt(X, W), W = #max {W1 : selected(Y), watt(Y, W1)}.\nmax_cost(X) :- cost(X, C), C = #max {C1 : selected(Y), cost(Y, C1)}.\n:- selected(X), max_watt(X), not max_cost(X).\n\n% Incompatible pairs: (HydraPro, VegaLite), (Eco600, StormZ).\n:- selected_cpu(\"HydraPro\"), selected_gpu(\"VegaLite\").\n:- selected_psu(\"Eco600\"), selected_gpu(\"StormZ\").\n\n% Do not select all three cheapest components\ncheapest_cpu(C) :- cpu(C), cost(C, V), V = #min {V1 : cpu(C1), cost(C1, V1)}.\ncheapest_gpu(G) :- gpu(G), cost(G, V), V = #min {V1 : gpu(G1), cost(G1, V1)}.\ncheapest_psu(P) :- psu(P), cost(P, V), V = #min {V1 : psu(P1), cost(P1, V1)}.\n:- selected_cpu(C), cheapest_cpu(C), selected_gpu(G), cheapest_gpu(G), selected_psu(P), cheapest_psu(P).\n\n% No two selected components can differ in cost by more than $400.\n:- selected(X), selected(Y), cost(X, CX), cost(Y, CY), CX - CY > 400.\n:- selected(X), selected(Y), cost(Y, CY), cost(X, CX), CY - CX > 400.\n"}]}
{"messages": [{"role": "system", "content": "You are an expert AI researcher. Translate the following structured intermediate representation (IR) into syntactically correct clingo ASP code."}, {"role": "user", "content": "4 Locations.\nAdjacent nodes: (1\u20132), (1\u20133), (2\u20134).\nThe drone can only move between adjacent nodes.\nThere are 5 timesteps.\nMust visit locations: 3, 4.\nThe drone starts at 1."}, {"role": "assistant", "content": "% 4 Locations\nloc(1..4).\n\n% Adjacent nodes: (1\u20132), (1\u20133), (2\u20134)\nedge(1, 2).\nedge(1, 3).\nedge(2, 4).\n\n% The drone can only move between adjacent nodes\n1 { at(L, T) : loc(L) } 1 :- time(T).\n:- at(L1, T), at(L2, T+1), not edge(L1, L2), not edge(L2, L1), time(T).\n\n% There are 5 timesteps\ntime(0..5).\n\n% Must visit locations: 3, 4\nat(3, _).\nat(4, _).\n\n% The drone starts at 1\nat(1, 0)."}]}
{"messages": [{"role": "system", "content": "You are an expert AI researcher. Translate the following structured intermediate representation (IR) into syntactically correct clingo ASP code."}, {"role": "user", "content": "Select one CPU from {Ryzen7, i9, Xeon}, with costs:\nRyzen7 = 300, i9 = 400, Xeon = 500.\nSelect one GPU from {RTX4060, RTX3090, Quadro}, with costs:\nRTX4060 = 350, RTX3090 = 700, Quadro = 800.\nSelect one motherboard from {X670, Z690, C621}, with costs:\nX670 = 180, Z690 = 200, C621 = 250.\nSelect one PSU from {Bronze, Gold, Platinum}, with costs:\nBronze = 80, Gold = 120, Platinum = 160.\nQuadro and RTX3090 are HighPower GPUs.\nHighPower GPUs require PSU \u2208 {Gold, Platinum}.\nXeon requires motherboard C621.\nRyzen7 requires motherboard X670.\ni9 is incompatible with motherboard X670.\nQuadro requires Xeon CPU.\nQuadro is incompatible with Z690.\nMinimize total cost."}, {"role": "assistant", "content": "% Select exactly one CPU from {Ryzen7, i9, Xeon}.\ncpu(\"Ryzen7\", 300; \"i9\", 400; \"Xeon\", 500).\n1 { selected_cpu(C) : cpu(C, _) } 1.\n\n% Select exactly one GPU from {RTX4060, RTX3090, Quadro}.\ngpu(\"RTX4060\", 350; \"RTX3090\", 700; \"Quadro\", 800).\n1 { selected_gpu(G) : gpu(G, _) } 1.\n\n% Select exactly one motherboard from {X670, Z690, C621}.\nmobo(\"X670\", 180; \"Z690\", 200; \"C621\", 250).\n1 { selected_mobo(M) : mobo(M, _) } 1.\n\n% Select exactly one PSU from {Bronze, Gold, Platinum}.\npsu(\"Bronze\", 80; \"Gold\", 120; \"Platinum\", 160).\n1 { selected_psu(P) : psu(P, _) } 1.\n\n% RTX3090 and Quadro are HighPower GPUs.\nhigh_power(\"RTX3090\"; \"Quadro\").\n\n% HighPower GPUs require PSU \u2208 {Gold, Platinum}.\n:- selected_gpu(G), high_power(G), selected_psu(\"Bronze\").\n\n% Xeon requires C621 motherboard.\n:- selected_cpu(\"Xeon\"), selected_mobo(M), M != \"C621\".\n\n% Ryzen7 requires X670 motherboard.\n:- selected_cpu(\"Ryzen7\"), selected_mobo(M), M != \"X670\".\n\n% i9 is incompatible with X670 motherboard.\n:- selected_cpu(\"i9\"), selected_mobo(\"X670\").\n\n% Quadro requires Xeon CPU.\n:- selected_gpu(\"Quadro\"), selected_cpu(C), C != \"Xeon\".\n\n% Quadro is incompatible with Z690 motherboard.\n:- selected_gpu(\"Quadro\"), selected_mobo(\"Z690\").\n\n% Minimize total cost.\ntotal_cost(Cost) :-\n    selected_cpu(C), cpu(C, CCost),\n    selected_gpu(G), gpu(G, GCost),\n    selected_mobo(M), mobo(M, MCost),\n    selected_psu(P), psu(P, PCost),\n    Cost = CCost + GCost + MCost + PCost.\n#minimize { C : total_cost(C) }."}]}
{"messages": [{"role": "system", "content": "You are an expert AI researcher. Translate the following structured intermediate representation (IR) into syntactically correct clingo ASP code."}, {"role": "user", "content": "Select exactly one CPU from {Ryzen5, i5}.\nSelect exactly one GPU from {GTX1660, RX580}.\nSelect exactly one motherboard from {B450, Z390}.\nThe Ryzen5 CPU requires the B450 motherboard.\nThe i5 CPU requires the Z390 motherboard.\nThe RX580 GPU is incompatible with the Z390 motherboard."}, {"role": "assistant", "content": "% Select exactly one CPU from {Ryzen5, i5}.\ncpu(\"Ryzen5\"; \"i5\").\n1 { selected_cpu(C) : cpu(C) } 1.\n\n% Select exactly one GPU from {GTX1660, RX580}.\ngpu(\"GTX1660\"; \"RX580\").\n1 { selected_gpu(G) : gpu(G) } 1.\n\n% Select exactly one motherboard from {B450, Z390}.\nmobo(\"B450\"; \"Z390\").\n1 { selected_mobo(M) : mobo(M) } 1.\n\n% The Ryzen5 CPU requires the B450 motherboard.\n:- selected_cpu(\"Ryzen5\"), selected_mobo(M), M != \"B450\".\n\n% The i5 CPU requires the Z390 motherboard.\n:- selected_cpu(\"i5\"), selected_mobo(M), M != \"Z390\".\n\n% The RX580 GPU is incompatible with the Z390 motherboard.\n:- selected_gpu(\"RX580\"), selected_mobo(\"Z390\").\n"}]}
{"messages": [{"role": "system", "content": "You are an expert AI researcher. Translate the following natural language problem description into syntactically correct clingo ASP code."}, {"role": "user", "content": "A water\u2011sampling drone is launched from the LaunchPad into a branching \nnetwork of subterranean aqueducts. It must collect samples at StationA \nand StationB, but can optionally sample at StationC if time allows. \nThe aqueducts are one\u2011way tunnels, each carrying a distinct water volume \ncost that reduces the drone\u2019s internal tank capacity (max 16\u202fL). Moving \nthrough any tunnel takes exactly 1\u202fminute, and collecting a sample at a \nstation requires 1\u202fminute and fills 1\u202fL.\nFrom LaunchPad, two connectors diverge: Tunnel1 (cost 2\u202fL) and Tunnel2 \n(cost 3\u202fL). Tunnel1 leads to StationA (1\u202fL), then onward to Tunnel3 \n(1\u202fL) which loops back to Tunnel2. Tunnel2 goes to StationB (1\u202fL) or to \na calibration shaft CalibEdge (2\u202fL), which itself permits entry into \nStationC (1\u202fL). StationC then funnels back to Tunnel1 at heavier volume \ncost (2\u202fL).\nThe drone begins with a full 16\u202fL tank at time\u202f0 and must operate within \n10\u202fminutes. It cannot exceed its tank capacity. It may refill 3\u202fL by \nidling 2 consecutive minutes at CalibEdge, but only once. The mission \nrequires at least one sample at StationA and StationB, with StationA\u2019s \nsample completed by minute\u202f6. StationC must only be sampled if and only \nif both mandatory samples finish within 8\u202fminutes. The total count of \nmovements, samplings, and refills must not exceed 18 events. The \ndrone may never sample twice in a row at the same station (to avoid \ncross\u2011contamination). Primary objective: maximize the total number of \nsamples (including optional). Secondary: minimize the time at which the \nlast mandatory sample completes."}, {"role": "assistant", "content": "% Locations: HubWest, NodeA, NodeB, Sensor1, Sensor2\nloc(\"HubWest\"; \"NodeA\"; \"NodeB\"; \"Sensor1\"; \"Sensor2\").\n\n% Edges: (HubWest\u2013NodeA), (HubWest\u2013NodeB), (NodeA\u2013Sensor1), (NodeB\u2013Sensor2), (NodeA\u2013NodeB)\nedge(\"HubWest\", \"NodeA\").\nedge(\"HubWest\", \"NodeB\").\nedge(\"NodeA\", \"Sensor1\").\nedge(\"NodeB\", \"Sensor2\").\nedge(\"NodeA\", \"NodeB\").\n\n% Max duration: 9 minutes\ntime(0..9).\n\n% Start location: HubWest\nat(\"HubWest\", 0).\n\n% Movement between adjacent nodes costs 1 minute\n1 { at(L, T) : loc(L) } 1 :- time(T).\n:- at(L1, T), at(L2, T+1), not edge(L1, L2), not edge(L2, L1), L1 != L2.\n\n% Sampling targets: Sensor1, Sensor2\ninspect(\"Sensor1\"; \"Sensor2\").\n\n% Each sample requires a full minute\n1 { inspect_at(L, T) : time(T) } 1 :- inspect(L).\nat(L, T) :- inspect_at(L, T).\nat(L, T+1) :- inspect_at(L, T), T < 9.\n\n% Minimize time by which both samples are completed\nlatest_inspect(T) :- T = #max { T1 : inspect_at(_, T1) }.\n#minimize { T : latest_inspect(T) }.\n\n% A minimum of three timesteps between samples\n:- inspect_at(_, T1), inspect_at(_, T2), 0 < T1 - T2 < 3.\n\n% If NodeB is visited before Sensor1, then NodeA may not be visited afterward\n:- at(\"NodeB\", T1), at(\"Sensor1\", T2), at(\"NodeA\", T3), T1 < T2 < T3.\n"}]}
